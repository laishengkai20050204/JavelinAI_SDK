

# 角色

你是资深 Java/Spring Boot WebFlux + Spring AI 工程师。请在不破坏现有编排与接口的前提下，完成下面的修复并提交**最小侵入式补丁**（diff）。

# 项目上下文（已存在）

* 后端：Java / Spring Boot WebFlux / Reactor
* 已有编排：`AiServiceImpl`（多轮 loop、SSE NDJSON、遇前端工具下发 `tool_request`、前端执行后 `/ai/continue` 回填 `role=tool`）
* 工具治理：`ToolRegistry` + `AiToolExecutor`（服务端工具）
* Spring AI 已接入：`SpringAiChatGateway` 封装 `ChatClient` 调用
* 前端请求示例（关键字段）：

```json
{
  "userId":"u10",
  "conversationId":"c1",
  "q":"严格要求：先调用服务端工具 find_relevant_memory ... 允许调用客户端 open_url ...",
  "toolChoice":"auto",
  "responseMode":"step-json-ndjson",
  "clientTools":[
    {"type":"function","function":{
      "name":"open_url",
      "description":"在浏览器中打开指定链接",
      "parameters":{"type":"object","properties":{"url":{"type":"string","format":"uri"}},"required":["url"]},
      "x-execTarget":"client"
    }}
  ]
}
```

* 需求：**前端工具**放在 `clientTools` 且 `x-execTarget:"client"`；**后端工具**由后端执行；模型应能“看到”前端工具（产出 `tool_call`），但不要在后端执行它；`toolChoice`（字符串或对象）要完整生效；每轮**收窄**可见的函数集合。

# 要解决的问题

现在“前端工具即使强制也不被调用”，原因是网关层未把前端工具定义提供给模型，或把可见函数清空，或丢失了对象形态的 `toolChoice`，并且后端可能“抢跑”执行。

# 目标（必须全部达成）

1. **前端工具“可见但不执行”**：注册“仅定义”的 `FunctionCallback`（只提供 name/parameters/description，`call()` 抛异常或占位），使模型可以产出该工具的 `tool_call`；
2. **后端工具可执行**：仍保留 Spring AI 对后端工具的可执行回调（不要求全局关闭内部执行）；
3. **收窄 & 强制**：每轮根据请求构建 `allowed` 函数名集合；若 `toolChoice` 为对象且指定函数名，则 `allowed={该函数}`；
4. **`toolChoice` 原样透传**：支持字符串（`auto|none|required`）与对象（`{"type":"function","function":{"name":"xxx"}}`），不要改丢对象形态；
5. **编排保持不变**：仍由 `AiServiceImpl` 分流：前端工具 → 下发 `tool_request`；后端工具 → 本地执行并注入 `role=tool`；支持 `/ai/continue` 回填继续。

# 修改范围（仅限）

* **必须修改**：`com.example.ai.SpringAiChatGateway`（或你工程里等价的网关封装类）
* **可选小改**：在 `AiServiceImpl` 发出的 `tool_request` 事件中附带 `execTarget`（若已有映射可不改）
* **不得修改**：公共接口契约、控制器 URL、已有 DTO 命名（除非为适配新增字段）

# 实施细节（务必按此实现）

1. 在 `SpringAiChatGateway` 里：

   * 解析并合并**两处**工具定义：`payload.clientTools[*]` 与 `payload.tools[*]`；
   * 识别 `x-execTarget`：默认 `"server"`，显式 `"client"` 视为前端工具；
   * 解析 `toolChoice`（兼容别名 `tool_choice`），新增方法 `forcedFunctionName(Object toolChoice)`，若对象形态指定了函数名，则返回该名；
   * 构建 `allowed`：若存在强制名则仅该函数，否则为“本次请求出现的所有函数名（前端+后端）”；
   * **后端回调集合**：从 `toolAdapter.functionCallbacks()` 里筛选 `name ∈ allowed`；
   * **前端定义回调集合**：对 `name ∈ allowed` 且 `x-execTarget=="client"` 且**后端无同名回调**的工具，创建 `FunctionCallback`：

     * `getName()` 返回工具名；
     * `getInputTypeSchema()` 直接使用前端传来的 JSON Schema；
     * `call(...)` 抛 `UnsupportedOperationException("frontend tool: " + name)`（避免后端误执行）；
   * `OpenAiChatOptions`：

     * `.functions(allowed)` 或 `.toolNames(allowed)`（依据项目使用的 API）；
     * `.functionCallbacks(后端回调 ∪ 前端定义回调)`；
     * **不要**因为“没有后端回调”就把 `functions` 清空；
     * `.toolChoice(toolChoice)`：字符串或 Map 原样设置（不要转换/丢弃对象形态）；
     * 是否 `.internalToolExecutionEnabled(false)`：**默认不改动**（保留你们现在“后端自动执行”的习惯）；如未来想统一受控再关闭。
   * **日志**（DEBUG）：

     * `[TOOLS-ALLOWED]` 打印 `allowed`；
     * `[CB-REGISTERED] server=<names> client-def=<names>`；
     * `[TOOL-CHOICE]` 打印传入的 `toolChoice`；
2. （可选）在 `AiServiceImpl` 的 SSE `tool_request` 事件 payload 里补充 `execTarget:"client"` 字段，方便前端做路由（若已有映射可忽略）。

# 代码骨架（请融合到网关类）

* 新增内部记录类型：

```java
record ToolDef(String name, String desc, JsonNode schema, String execTarget) {}
```

* 新增方法：

```java
// 解析 clientTools + tools，提取 name/desc/schema/execTarget
private List<ToolDef> parseAllToolDefs(Map<String,Object> payload);

// 解析对象形态 toolChoice，返回被强制的函数名或 null
private @Nullable String forcedFunctionName(Object toolChoice);

// 构建回调：后端保留原回调，前端生成“仅定义回调”
private List<FunctionCallback> buildCallbacks(List<ToolDef> defs, Set<String> allowed, List<FunctionCallback> serverCallbacks);
```

* 在构建 `OpenAiChatOptions` 时：

```java
List<ToolDef> defs = parseAllToolDefs(payload);
Object toolChoice = payload.getOrDefault("toolChoice", payload.get("tool_choice"));
String forced = forcedFunctionName(toolChoice);

Set<String> allowed = (forced != null)
    ? Set.of(forced)
    : defs.stream().map(ToolDef::name).collect(Collectors.toCollection(LinkedHashSet::new));

List<FunctionCallback> serverCallbacks = toolAdapter.functionCallbacks().stream()
    .filter(cb -> allowed.contains(cb.getName()))
    .toList();

List<FunctionCallback> clientDefCallbacks = buildCallbacks(defs, allowed, serverCallbacks);

OpenAiChatOptions.Builder b = OpenAiChatOptions.builder()
    .functions(allowed)
    .functionCallbacks(Stream.concat(serverCallbacks.stream(), clientDefCallbacks.stream()).toList())
    .parallelToolCalls(true); // 可选

if (toolChoice instanceof String s) b.toolChoice(s);
else if (toolChoice != null) b.toolChoice(toolChoice);

log.debug("[TOOLS-ALLOWED] {}", allowed);
log.debug("[CB-REGISTERED] server={}, client-def={}",
    serverCallbacks.stream().map(FunctionCallback::getName).toList(),
    clientDefCallbacks.stream().map(FunctionCallback::getName).toList());
log.debug("[TOOL-CHOICE] {}", toolChoice);

return b.build();
```

# 验收标准（必须全通过）

1. **前端-only 强制**：请求只包含 `clientTools=[open_url]` 且 `toolChoice={"type":"function","function":{"name":"open_url"}}` → 模型返回的 `tool_calls[0].function.name=="open_url"`，后端不执行，SSE 下发 `tool_request`。
2. **混合 + 强制前端**：同时提供 `find_relevant_memory`（后端）与 `open_url`（前端），`toolChoice` 指向 `open_url` → 仅出现 `open_url` 的 `tool_call` 并下发给前端。
3. **混合 + 强制后端**：强制 `find_relevant_memory` → 直接由后端执行并注入 `role=tool`，进入下一轮。
4. **`toolChoice:"none"`**：无 `tool_calls`，直接生成文本回答。
5. **日志**：出现上述三条 DEBUG 日志，且 `client-def` 显示前端工具名。

# 手工测试（示例）

```bash
# 1) 强制前端工具
curl -N -H "Accept: text/event-stream" -H "Content-Type: application/json" \
  -X POST http://localhost:8080/ai/decide/stream \
  -d '{
    "mode":"OPENAI","model":"gpt-4o-mini",
    "messages":[{"role":"user","content":"请打开官网 https://example.com"}],
    "clientTools":[{"type":"function","function":{
      "name":"open_url","description":"open","parameters":{"type":"object","properties":{"url":{"type":"string","format":"uri"}},"required":["url"]},"x-execTarget":"client"}}],
    "toolChoice":{"type":"function","function":{"name":"open_url"}}
  }'

# 2) 混合，自动选择（期望：先 find_relevant_memory，再可能出现 open_url）
curl -N -H "Accept: text/event-stream" -H "Content-Type: application/json" \
  -X POST http://localhost:8080/ai/decide/stream \
  -d '{"mode":"OPENAI","model":"gpt-4o-mini","messages":[{"role":"user","content":"先查记忆再回答，可选打开官网"}],
       "tools":[{"type":"function","function":{"name":"find_relevant_memory","parameters":{"type":"object","properties":{"query":{"type":"string"},"maxMessages":{"type":"integer"}},"required":["query"]}}}],
       "clientTools":[{"type":"function","function":{"name":"open_url","parameters":{"type":"object","properties":{"url":{"type":"string","format":"uri"}},"required":["url"]},"x-execTarget":"client"}}],
       "toolChoice":"auto"}'
```

# 交付物

* 修改后的 Java 源码（按上述位置与方法）
* 提交信息：

```
fix(tools): expose client tools to model, honor object toolChoice, narrow functions per call; keep server tools executable; emit debug logs
```

# 额外要求

* **不要**更改公开接口签名与返回格式；
* **不要**删除现有编排逻辑；
* 单测/手测通过上述验收标准；
* 代码风格与现有项目保持一致（lombok/日志/命名）。

---
